# 05-a-2000.txt
Сменете вашия prompt с нещо по желание. После върнете оригиналния обратно.
```
vim .bashrc
we break the promt
source .bashrc
```

# 05-a-2100.txt
Редактирайте вашия .bash_profile файл, за да ви поздравява (или да изпълнява някаква команда по ваш избор) всеки път, когато влезете в системата.
```
as of 16/05/23 there is no exact file match
.profile is probably the answer
```

# 05-a-2200.txt
Направете си ваш псевдоним (alias) на полезна команда.
```bash
alias kondio='echo "Doko, doko - kembashe skokalo mach"'
```

# 05-b-2000.txt
Да се напише shell скрипт, който приканва потребителя да въведе низ (име) и изпечатва "Hello, низ".
```
./greeting.sh
```

# 05-b-2800.txt
Да се напише shell скрипт, който приема точно един параметър и проверява дали подаденият му параметър се състои само от букви и цифри.
```
./isAllLettersOrAllNumbers.sh asd123
```

# 05-b-3100.txt
Да се напише shell скрипт, който приканва потребителя да въведе низ - потребителско име на потребител от системата - след което извежда на стандартния изход колко активни сесии има потребителят в момента.
```
./activeSessions.sh
```

# 05-b-3200.txt
Да се напише shell скрипт, който приканва потребителя да въведе пълното име на директория и извежда на стандартния изход подходящо съобщение за броя на всички файлове и всички директории в нея.
```
./dirItems.sh
```

# 05-b-3300.txt
Да се напише shell скрипт, който чете от стандартния вход имената на 3 файла, обединява редовете на първите два (man paste), подрежда ги по азбучен ред и резултата записва в третия файл.
```
./pasteTwoFiles.sh
file1
file2
file3
```

# 05-b-3400.txt
Да се напише shell скрипт, който чете от стандартния вход име на файл и символен низ, проверява дали низа се съдържа във файла и извежда на стандартния изход кода на завършване на командата с която сте проверили наличието на низа.

NB! Символният низ може да съдържа интервал (' ') в себе си.
```
./isStringInFile.sh
file1
string
```

## **05-b-4200.txt**
Имате компилируем (a.k.a няма синтактични грешки) source file на езика C. Напишете shell script, който да покaзва колко е дълбоко най-дълбокото nest-ване (влагане).

Примерен .c файл:
```c
#include <stdio.h>

int main(int argc, char *argv[]) {

  if (argc == 1) {
		printf("There is only 1 argument");
	} else {
		printf("There are more than 1 arguments");
	}

	return 0;
}
```
Тук влагането е 2, понеже имаме main блок, а вътре в него if блок.

Примерно извикване на скрипта:
./count_nesting sum_c_code.c
Изход:
The deepest nesting is 2 levels
```
./biggestNestingInCProgram.sh cProgram.c
```

# 05-b-4301.txt
Напишете shell script, който автоматично да попълва файла указател от предната задача по подадени аргументи: име на файла указател, пълно име на човека (това, което очакваме да е в /etc/passwd) и избран за него nickname.
Файлът указател нека да е във формат:
<nickname, който лесно да запомните> <username в os-server>
// може да сложите и друг delimiter вместо интервал

Примерно извикване:
./pupulate_address_book myAddressBook "Ben Dover" uncleBen

Добавя към myAddressBook entry-то:
uncleBen <username на Ben Dover в os-server>

***Бонус: Ако има няколко съвпадения за въведеното име (напр. има 10 човека Ivan Petrov в /etc/passwd), всички те да се показват на потребителя, заедно с пореден номер >=1,
след което той да може да въведе някой от номерата (или 0 ако не си хареса никого), и само избраният да бъде добавен към указателя.
```
nz kakva e prednata zad :\
```

# 05-b-4400.txt
Напишете shell script, който да приема параметър име на директория, от която взимаме файлове, и опционално експлицитно име на директория, в която ще копираме файлове. Скриптът да копира файловете със съдържание, променено преди по-малко от 45 мин, от първата директория във втората директория. Ако втората директория не е подадена по име, нека да получи такова от днешната дата във формат, който ви е удобен. При желание новосъздадената директория да се архивира.
```
./copyDirInDir.sh dir1 (dir2)
```