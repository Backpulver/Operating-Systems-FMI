## **03-a-0200.txt**
Сортирайте /etc/passwd лексикографски по поле UserID.
```bash
sort -t':' -k3 /etc/passwd
```

## **03-a-0201.txt**
Сортирайте /etc/passwd числово по поле UserID.
(Открийте разликите с лексикографската сортировка)
```bash
sort -n -t':' -k3 /etc/passwd
```

## **03-a-0210.txt**
Изведете само 1-ва и 5-та колона на файла /etc/passwd спрямо разделител ":".
```bash
cut -d':' -f1,5 /etc/passwd
```


## **03-a-0211.txt**
Изведете съдържанието на файла /etc/passwd от 2-ри до 6-ти символ.
```bash
cut -c2-6 /etc/passwd
```

## **03-a-0212.txt**
Отпечатайте потребителските имена и техните home директории от /etc/passwd.
```bash
cut -d':' -f1,6 /etc/passwd
```

## **03-a-0213.txt**
Отпечатайте втората колона на /etc/passwd, разделена спрямо символ '/'.
```bash
cut -d'/' -f2 /etc/passwd
```

## **03-a-1500.txt**
- Изведете броя на байтовете в /etc/passwd.
- Изведете броя на символите в /etc/passwd.
- Изведете броя на редовете в /etc/passwd.
```bash
wc -c /etc/passwd
wc -m /etc/passwd
wc -l /etc/passwd
```

## **03-a-2000.txt**
С отделни команди, извадете от файл /etc/passwd:
- първите 12 реда
- първите 26 символа
- всички редове, освен последните 4
- последните 17 реда
- 151-я ред (или друг произволен, ако нямате достатъчно редове)
- последните 4 символа от 13-ти ред (символът за нов ред не е част от реда)
```bash
head -n12 /etc/passwd
head -n1 /etc/passwd | cut -c-26
head -n-4 /etc/passwd
tail -n17 /etc/passwd
head -n151 /etc/passwd | tail -n1
head -n13 /etc/passwd | tail -n1 | rev | cut -c-4 | rev
```

## **03-a-3000.txt**
Запаметете във файл в своята home директория резултатът от командата `df -P`.
Напишете команда, която извежда на екрана съдържанието на този файл, без първия ред (хедъра), сортирано по второ поле (numeric).
```bash
df -P > outputDF.txt
tail -n+2 outputDF.txt | sort -n -k2
```
Особеност при tail с аргумент +2!

## **03-a-3100.txt**
Запазете само потребителските имена от /etc/passwd във файл users във вашата home директория.
```bash
cut -d':' -f1 /etc/passwd > usernames.txt
```

## **03-a-3500.txt**
Изпишете всички usernames от /etc/passwd с главни букви.
```bash
cat usernames.txt | tr [:lower:] [:upper:]
```

## **03-a-5000.txt**
- Изведете реда от /etc/passwd, на който има информация за вашия потребител.
- Изведедете този ред и двата реда преди него.
- Изведете този ред, двата преди него, и трите след него.
- Изведете *само* реда, който се намира 2 реда преди реда, съдържащ информация за вашия потребител.
```bash
grep 62593 /etc/passwd
grep -B2 62593 /etc/passwd
grep -B2 -A3 62593 /etc/passwd
grep -B2 62593 /etc/passwd | head -n1
```

## **03-a-5001.txt**
Изведете колко потребители не изпозват /bin/bash за login shell според /etc/passwd
(hint: 'man 5 passwd' за информация какъв е форматът на /etc/passwd)
```bash
cut -d':' -f7 /etc/passwd | grep -v "/bin/bash" | wc -l
```

## **03-a-5002.txt**
Изведете само имената на хората с второ име по-дълго от 6 (>6) символа според /etc/passwd
Уточнение: имената на български се броят за 2 символа поради някаква причина
```bash
cut -d' ' -f2 /etc/passwd | cut -d',' -f1 | egrep "^.{14,}$"
```

## **03-a-5003.txt**
Изведете имената на хората с второ име по-късо от 8 (<=7) символа според /etc/passwd // !(>7) = ?
```bash
cut -d' ' -f2 /etc/passwd | cut -d',' -f1 | egrep "^.{,14}$"
```

## **03-a-5004.txt**
Изведете целите редове от /etc/passwd за хората от 03-a-5003
```bash
grep "$(cut -d' ' -f2 /etc/passwd | cut -d',' -f1 | egrep "^.{,14}$" )" /etc/passwd
```

## **03-a-6000.txt**
Копирайте <РЕПО>/exercises/data/emp.data във вашата home директория.
Посредством awk, използвайки копирания файл за входнни данни, изведете:

- общия брой редове
```bash
awk 'END{print NR}' emp.data 
```
- третия ред
```bash
awk 'FNR == 3 {print}' emp.data
```
- последното поле от всеки ред
```bash
awk '{print $NF}' emp.data
```
- последното поле на последния ред
```bash
awk 'END {print $NF}' emp.data
```
- всеки ред, който има повече от 4 полета
(Няма такъв?)
```bash
awk 'NF > 4 {print}' emp.data
```
- всеки ред, чието последно поле е по-голямо от 4
```bash
awk '$NF > 4 {print}' emp.data 
```
- общия брой полета във всички редове
```bash
awk '{print NF}' emp.data
```
- броя редове, в които се среща низът Beth
```bash
awk '/Beth/' emp.data | wc -l
```
- най-голямото трето поле и редът, който го съдържа
```bash
awk 'BEGIN {a=0} {if ($3 >= a) a=$3" " $0} END {print a}' emp.data
```
- всеки ред, който има поне едно поле
```bash
awk 'NR >= 1 {print}' emp.data 
```
- всеки ред, който има повече от 17 знака
```bash
awk '{if (length($0) > 17) print $0}' emp.data
```
- броя на полетата във всеки ред и самият ред
```bash
awk '{print NF, $0}' emp.data
```
- първите две полета от всеки ред, с разменени места
```bash
awk '{print $2, $1}' emp.data
```
- всеки ред така, че първите две полета да са с разменени места
```bash
awk '{tmp=$1; $1=$2; $2=tmp} {print $0}' emp.data
```
- всеки ред така, че на мястото на първото поле да има номер на реда
```bash
awk '{$1=NR; print $0}' emp.data
```
- всеки ред без второто поле
```bash
awk '{$2=""; print $0}' emp.data
```
- за всеки ред, сумата от второ и трето поле
```bash
 awk '{print $2+$3}' emp.data
```
- сумата на второ и трето поле от всеки ред
```bash
awk '{sum2+=$2; sum3+=$3}END {print sum2+sum3}' emp.data
```

## **03-b-0300.txt**
Намерете само Group ID-то си от файлa /etc/passwd.
(Hint: man 5 passwd)
```bash
grep 62593 /etc/passwd | cut -d':' -f4
```

## **03-b-3400.txt**
Колко коментара има във файла /etc/services ? Коментарите се маркират със символа #, след който всеки символ на реда се счита за коментар.
```bash
grep "^#" /etc/services | wc -l
```

## **03-b-3500.txt**
Колко файлове в /bin са 'shell script'-oве? 
(Колко файлове в дадена директория са ASCII text?) -> yeah, not really
```bash
egrep "^#!" /bin/* 2>/dev/null | wc -l
file /bin/* grep "ASCII text" 2>/dev/null | wc -l
```

## **03-b-3600.txt**
Направете списък с директориите на вашата файлова система, до които нямате достъп. Понеже файловата система може да е много голяма, търсете до 3 нива на дълбочина.
```bash
find / -maxdepth 3 -type d 2>noAccessDirs.txt
```

## **03-b-4000.txt**
Създайте следната файлова йерархия в home директорията ви:
dir5/file1
dir5/file2
dir5/file3
Посредством vi въведете следното съдържание:

file1:
1
2
3

file2:
s
a
d
f

file3:
3
2
1
45
42
14
1
52

Изведете на екрана:
* статистика за броя редове, думи и символи за всеки един файл
* статистика за броя редове и символи за всички файлове
* общия брой редове на трите файла
```bash
wc file1 file2 file3 | head -n-1
wc -lm file1 file2 file3 | head -n-1
wc -l file1 file2 file3 | tail -n1
```

## **03-b-4001.txt**
Във file2 (inplace) подменете всички малки букви с главни.
```bash
cat file2 | tr [:lower:] [:upper:]
```

## **03-b-4002.txt**
Във file3 (inplace) изтрийте всички "1"-ци.
```bash
cat file3 | tr -d 1
```

## **03-b-4003.txt**
Изведете статистика за най-често срещаните символи в трите файла.
```bash
cat file1 file2 file3 | sort | uniq -c
```

## **03-b-4004.txt**
Направете нов файл с име по ваш избор, чието съдържание е конкатенирани съдържанията на file{1,2,3}.
```bash
cat file1 file2 file3 > newFile
```

## **03-b-4005.txt**
Прочетете текстов файл file1 и направете всички главни букви малки като
запишете резултата във file2.
```bash
cat file1 | tr [:upper:] [:lower:] >> file2
```

## **03-b-5200.txt**
Намерете броя на символите, различни от буквата 'а' във файла /etc/passwd
```bash
sed s/a//g /etc/passwd | wc -m
```

## **03-b-5300.txt**
Намерете броя на уникалните символи, използвани в имената на потребителите от
/etc/passwd.
```bash
cut -d':' -f5 /etc/passwd | cut -d',' -f1 | grep -o . | sort -u | wc -l
```

## **03-b-5400.txt**
Отпечатайте всички редове на файла /etc/passwd, които не съдържат символния низ 'ов'.
```bash
grep -v 'ов' /etc/passwd
```

## **03-b-6100.txt**
Отпечатайте последната цифра на UID на всички редове между 28-ми и 46-ред в /etc/passwd.
```bash
head -n46 /etc/passwd | tail -n28 | cut -d':' -f3 | grep -o ".$"
```

## **03-b-6700.txt**
Отпечатайте правата (permissions) и имената на всички файлове, до които имате
read достъп, намиращи се в директорията /tmp.
(hint: 'man find', вижте -readable)
```bash
find /tmp/ -readable 2>/dev/null -printf "%M %p\n"
```

## **03-b-6900.txt**
Намерете имената на 10-те файла във вашата home директория, чието съдържание е
редактирано най-скоро. На първо място трябва да бъде най-скоро редактираният
файл. Намерете 10-те най-скоро достъпени файлове. 
(hint: Unix time)
```bash
find ~/ -printf "%A@ %p\n" | sort -n | tail
```

## **03-b-7000.txt**
да приемем, че файловете, които съдържат C код, завършват на `.c` или `.h`.
Колко на брой са те в директорията `/usr/include`?
Колко реда C код има в тези файлове?
```bash
find /usr/include/ -type f | grep "\.[ch]$" | wc -l
```

## **03-b-7500.txt**
Даден ви е ASCII текстов файл - /etc/services. Отпечатайте хистограма на 10-те най-често срещани думи.
Дума наричаме непразна последователност от букви. Не правим разлика между главни и малки букви.
Хистограма наричаме поредица от редове, всеки от които има вида:
<брой срещания> <какво се среща толкова пъти>
```bash
cat /etc/scat /etc/services | tr -s '[\t ]' '\n' | sort | uniq -c
```

## **03-b-8000.txt**
Вземете факултетните номера на студентите (описани във файла
<РЕПО>/exercises/data/mypasswd.txt) от СИ и ги запишете във файл si.txt сортирани.
Студент е част от СИ, ако home директорията на този потребител (според
<РЕПО>/exercises/data/mypasswd.txt) се намира в /home/SI директорията.
(Hint: <РЕПО> = /srv/fmi-os)
```bash
cat /srv/fmi-os/exercises/data/mypasswd.txt | grep /home/SI | cut -d':' -f1 | grep '[0-9]' | tr -d 's' > si.txt
```

## **03-b-8500.txt**
За всяка група от /etc/group изпишете "Hello, <група>", като ако това е вашата група, напишете "Hello, <група> - I am here!".
```bash
cut -d':' -f1 /etc/group | sed -r s/^/Hello,\ / | sed -r s/$(groups)/$(groups)\ -\ I\ am\ here\!/
```

## **03-b-8600.txt**
Shell Script-овете са файлове, които по конвенция имат разширение .sh. Всеки
такъв файл започва с ``"#!<interpreter>"`` , където ``<interpreter>`` указва на
операционната система какъв интерпретатор да пусне (пр: "#!/bin/bash",
"#!/usr/bin/python3 -u").

Намерете всички .sh файлове в директорията `/usr` и нейните поддиректории, и
проверете кой е най-често използваният интерпретатор.
```bash
find /usr/ -type f -name "*.sh" -exec grep "^#\!" {} \; | cut -d'/' -f3 | sort | uniq -c | sort -n | tail -n1
```

## **03-b-8700.txt**
1. Изведете GID-овете на 5-те най-големи групи спрямо броя потребители, за които
съответната група е основна (primary).
(Hint: GID = GroupID)
2. `(*)` Изведете имената на съответните групи.
Hint: /etc/passwd
```bash
cut -d':' -f4 /etc/passwd | sort -n | uniq -c | sort -n | tail -n5
Нямам идея за 2., но -> getent group може да е полезно
```

## **03-b-9000.txt**
Направете файл eternity. Намерете всички файлове, намиращи се във вашата home
директория и нейните поддиректории, които са били модифицирани в последните
15мин (по възможност изключете .). Запишете във eternity името (път) на
файла и времето (unix time) на последната промяна.
```bash
touch eternity
find ~/ -type f -mmin -15 -printf "%p %T@\n" > eternity
```

## **03-b-9050.txt**
Копирайте файл <РЕПО>/exercises/data/population.csv във вашата home директория.
```bash
cp /srv/fmi-os/exercises/data/population.csv ~/
```

## **03-b-9051.txt**
Използвайки файл population.csv, намерете колко е общото население на света
през 2008 година. А през 2016?
```bash
grep 2008 population.csv | awk -F',' '{sum+=$4} END{print sum}'
grep 2016 population.csv | awk -F',' '{sum+=$4} END{print sum}'
```

## **03-b-9052.txt**
Използвайки файл population.csv, намерете през коя година в България има най-много население.
```bash
grep Bulgaria population.csv | sort -n -t',' -k4 | tail -n1 | cut -d',' -f3
```

## **03-b-9053.txt**
Използвайки файл population.csv, намерете коя държава има най-много население през 2016. А коя е с най-малко население?
(Hint: Погледнете имената на държавите)
```bash
grep 2016 population.csv | sort -n -t',' -k4 | tail -n1
grep 2016 population.csv | sort -n -t',' -k4 | head -n1
```

## **03-b-9054.txt**
Използвайки файл population.csv, намерете коя държава е на 42-ро място по
население през 1969. Колко е населението й през тази година?
```bash
grep 1969 population.csv | sort -nr -t',' -k4 | head -n42 | tail -n1
```

## **03-b-9100.txt**
В home директорията си изпълнете командата
curl -o songs.tar.gz "http://fangorn.uni-sofia.bg/misc/songs.tar.gz"
```bash
curl -o songs.tar.gz "http://fangorn.uni-sofia.bg/misc/songs.tar.gz"
```

## **03-b-9101.txt**
Да се разархивира архивът songs.tar.gz в директория songs във вашата home директория.
```bash
tar -xzf songs.tar.gz
```

## **03-b-9102.txt**
Да се изведат само имената на песните.
```bash
find ~/ -name "*.ogg" | cut -d'-' -f2 | cut -d'(' -f1
```

## **03-b-9103.txt**
Имената на песните да се направят с малки букви, да се заменят спейсовете с
долни черти и да се сортират.
```bash
find ~/ -name "*.ogg" | cut -d'-' -f2 | cut -d'(' -f1 | tr [[:upper:]] [[:lower:]] | cut -d' ' -f2- | tr ' ' '_' | sed -r s/.$// | sort
```

## **03-b-9104.txt**
Да се изведат всички албуми, сортирани по година.
```bash
find ~/ -name "*.ogg" | cut -d'(' -f2 | tr -d ').ogg' | sed -r s/,./_/ | sort -n -t'_' -k2 | uniq
```

## **03-b-9105.txt**
Да се преброят/изведат само песните на Beatles и Pink.
```bash
find ~/ -name "*.ogg" | cut -d'/' -f5 | grep -v "Pink Floyd" | grep -v "Madness" | wc -l

find ~/ -name "*.ogg" | cut -d'/' -f5 | grep -v "Pink Floyd" | grep -v "Madness" | cut -d' ' -f3- | cut -d'(' -f1
```

## **03-b-9106.txt**
Да се направят директории с имената на уникалните групи. За улеснение, имената
от две думи да се напишат слято:  Beatles, PinkFloyd, Madness
```bash
nz :\ ...i ne iskam da znam
```

## **03-b-9200.txt**
Напишете серия от команди, които извеждат детайли за файловете и директориите в
текущата директория, които имат същите права за достъп както най-големият файл
в /etc директорията.
```bash
batko
```

## **03-b-9300.txt**
Дадени са ви 2 списъка с email адреси - първият има 12 валидни адреса, а
вторията има само невалидни. Филтрирайте всички адреси, така че да останат
само валидните. Колко кратък регулярен израз можете да направите за целта?

Валидни email адреси (12 на брой):
email@example.com
firstname.lastname@example.com
email@subdomain.example.com
email@123.123.123.123
1234567890@example.com
email@example-one.com
_______@example.com
email@example.name
email@example.museum
email@example.co.jp
firstname-lastname@example.com
unusually.long.long.name@example.com

Невалидни email адреси:
#@%^%#$@#$@#.com
@example.com
myemail
Joe Smith <email@example.com>
email.example.com
email@example@example.com
.email@example.com
email.@example.com
email..email@example.com
email@-example.com
email@example..com
Abc..123@example.com
(),:;<>[\]@example.com
just"not"right@example.com
this\ is"really"not\allowed@example.com
```bash
se setish
```

## **03-b-9400.txt**
Посредством awk, използвайки emp.data (от 03-a-6000.txt) за входнни данни,
изведете:
- всеки ред, като полетата са в обратен ред
(Hint: Разгледайте for цикли в awk)
```bash
awk '{a[NR]=$0} END{for(i=NR;i>=1;i--) print a[i]}' emp.data
```

## **03-b-9500.txt**
Копирайте <РЕПО>/exercises/data/ssa-input.txt във вашата home директория.
Общият вид на файла е:

- заглавна част:
Smart Array P440ar in Slot 0 (Embedded)

- една или повече секции за масиви:
Array A
Array B
...
като буквата (A, B, ...) е името на масива

- във всяка таква секция има една или повече подсекции за дискове:
physicaldrive 2I:0:5
physicaldrive 2I:0:6
...
като 2I:0:5 е името на диска

- във всяка подсекция за диск има множество параметри във вида:
key name: value
като за нас са интересни само:
Current Temperature (C): 35
Maximum Temperature (C): 36

Напишете поредица от команди която обработва файл в този формат, и генерира
следният изход:
A-2I:0:5 35 36
A-2I:0:6 34 35
B-1I:1:1 35 50
B-1I:1:2 35 49

където `x-yyyyyy zz ww`:
- x е името на масива
- yyyyyy е името на диска
- zz е current temperature
- ww е max temperature
```bash
sed s/physicaldrive// ssa-input.txt | sed -r s/^[\t\ ]*// | sed -r s/^1I:/B-1I:/ | sed -r s/^2I:/A-2I:/ | egrep "[AB]-[12]I:[01]:[5612]|Temperature" | sed s/Current/Maximum/ | sed s/Maximum\ Temperature\ \(C\):\ // | tr -d '\n' 
to do
```